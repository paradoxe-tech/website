<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>CallMeKitsu. | RinthLab</title>
  <link href="style.css" rel="stylesheet" type="text/css" />
  <link href="../../cdn/styles/rules.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div id='main' style=''>
    <h1> Rinth Lab</h1>
    <h3>Algorithme d'Exploration exhaustive</h3>
    <h5>Randomized depth-first search (recursive way)</h5>
    <p>On part d'un labyrinthe rempli de murs. Au fur et à mesure de la construction, les cellules "visitées" seront identifiables. On crée une pile (<a title="principe lié au backtracking, et permet de sauvegarder efficacement l'historique des positions pour faciliter le retour en arrière" style='color: white;cursor: help;'>stack</a>) dans laquelle on stockera l'ensemble des <a title="l'ensemble des cases visitées dans l'ordre" style='color: white;cursor: help;'>positions successives du curseur</a>. Il suffira ensuite de choisir une cellule, d'ouvrir aléatoirement un des murs de celle-ci et d'avancer dans la suivante, jusqu'à un cul-de-sac. A ce moment, on retourne à une ancienne position dans la pile, qui nous permettra d'ouvrir un nouveau chemin et ainsi de suite jusqu'à la fin des possibilités. Ce principe est appelé <a title="algorithme reposant sur la récursivité, revenant en arrière pour toute erreur jusqu'à la résolution du problème" style='color: white;cursor: help;'>Recursive Backtracker algorithm</a>. </p>
    <div id="dfs" class='maze' style="overflow-wrap: break-word; line-height: 14px; letter-spacing: -2px;"></div>
    
    <h3>Algorithme aléatoire de Prim</h3>
    <h5>Randomized Prim's algorithm (modified version)</h5>
    <p>On commence avec un labyrinthe rempli de murs. On choisit ensuite une celulle arbitrairement, et on l'ajoute au labyrinthe. Ensuite, on choisit une des cellules déjà ajoutées, on garde la liste de cellules adjacentes à celle-ci et disponibles, on en choisit une aléatoirement et on l'ajoute au labyrinthe. Cette action sera répétée jusqu'à ce qu'aucune cellule ne soit disponible. Les cellules "adjacentes" sont celles qui sont à une distance dans n'importe quelle direction de 2 et qui n'ont pas encore été ajoutées au labyrinthe.</p>
    <div id="prim" class='maze' style="overflow-wrap: break-word; line-height: 14px; letter-spacing: -2px;"></div>

      <h3>Algorithme de Kruskal</h3>
      <h5>Randomized Kruskal's algorithm (Min. Spanning Tree)</h5>
      <p>A partir d'un labyrinthe rempli de murs, on assigne à chaque cellule un <a title="il peut être un nombre, une lettre ou n'importe quel symbole ou trait unique" style='color: white;cursor: help;'>identifiant unique</a>. Ensuite, on sélectionnera aléatoirement deux cellules adjacentes et brisera le mur qui les sépare. Ces dernières seront ajoutées au labyrinthe. Les deux cellules maintenant liées partageront l'identifiant de l'une des deux (aléatoirement). On recommencera ce principe jusqu'à ce que l'ensemble des cellules porte le même identifiant. De cette manière, on s'asure qu'il n'existe bien qu'un chemin unique entre deux points.</p>
      <div id="kruskal" class='maze' style="overflow-wrap: break-word; line-height: 14px; letter-spacing: -2px;"></div>
  </div>
  
  <br>@CallMeKitsu. (C) 2022<br><br>
  <script src="dfs.js"></script>
  <script src="prim.js"></script>
  <script src="kruskal.js"></script>
  <script src="script.js"></script>
</body>

</html>